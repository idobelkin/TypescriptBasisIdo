{"version":3,"sources":["webpack://fs/webpack/universalModuleDefinition","webpack://fs/webpack/bootstrap","webpack://fs/./src/utils.js","webpack://fs/./src/errors.js","webpack://fs/./src/root.js","webpack://fs/./src/directory.js","webpack://fs/./src/index.js","webpack://fs/./src/file.js","webpack://fs/./src/stat.js","webpack://fs/./src/quota.js"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","getCallback","resolve","arguments","length","args","getErrback","err","method","reject","e","argsStr","JSON","stringify","ex","join","message","promiseCall","obj","Error","slice","Promise","callback","errback","fullArgs","concat","apply","parsePath","path","parts","splitPath","fileName","pop","dirPath","replace","endsWith","split","filter","Boolean","isNotFoundError","isTypeMismatchError","type","set","newRoot","newType","getType","utils","require","errors","createChildDir","parent","dirName","exclusive","getChildDir","options","isDirectory","DOMError","reduce","res","then","dir","task","read","readEntriesRecursive","reader","acc","entries","createReader","readDeep","tasks","map","entry","subEntries","assign","children","all","file","directory","stat","quota","moveOrCopy","oldPath","newPath","newParentDirPath","newName","getEntry","enrty","newParent","assertType","PERSISTENT","TEMPORARY","isSupported","webkitRequestFileSystem","init","bytes","shouldRequestQuota","requestQuota","requestPersistent","grantedBytes","fs","usage","getRoot","readFile","fileEntry","writeFile","data","overwrite","write","append","appendFile","unlink","rename","copy","rmdir","mkdir","exists","readdir","deep","clear","getUrl","toURL","createReadStream","createWriteStream","getMimeTypeByData","readAs","readAsArrayBuffer","readAsBinaryString","readAsDataURL","readAsText","freezeMutableFile","Response","blob","createChildFile","getChildFile","isFile","fileWriter","seek","onwriteend","truncated","this","truncate","position","onerror","Blob","FileReader","onload","result","error","TransformStream","readable","writable","body","pipeTo","abort","WritableStream","start","close","metadata","fullPath","modificationTime","size","getStorageByType","navigator","webkitPersistentStorage","webkitTemporaryStorage","storage","usedBytes"],"mappings":";CAAA,SAA2CA,EAAMC,GAC1B,iBAAZC,SAA0C,iBAAXC,OACxCA,OAAOD,QAAUD,IACQ,mBAAXG,QAAyBA,OAAOC,IAC9CD,OAAO,GAAIH,GACe,iBAAZC,QACdA,QAAY,GAAID,IAEhBD,EAAS,GAAIC,IARf,CASGK,QAAQ,WACX,O,YCTE,IAAIC,EAAmB,GAGvB,SAASC,EAAoBC,GAG5B,GAAGF,EAAiBE,GACnB,OAAOF,EAAiBE,GAAUP,QAGnC,IAAIC,EAASI,EAAiBE,GAAY,CACzCC,EAAGD,EACHE,GAAG,EACHT,QAAS,IAUV,OANAU,EAAQH,GAAUI,KAAKV,EAAOD,QAASC,EAAQA,EAAOD,QAASM,GAG/DL,EAAOQ,GAAI,EAGJR,EAAOD,QA0Df,OArDAM,EAAoBM,EAAIF,EAGxBJ,EAAoBO,EAAIR,EAGxBC,EAAoBQ,EAAI,SAASd,EAASe,EAAMC,GAC3CV,EAAoBW,EAAEjB,EAASe,IAClCG,OAAOC,eAAenB,EAASe,EAAM,CAAEK,YAAY,EAAMC,IAAKL,KAKhEV,EAAoBgB,EAAI,SAAStB,GACX,oBAAXuB,QAA0BA,OAAOC,aAC1CN,OAAOC,eAAenB,EAASuB,OAAOC,YAAa,CAAEC,MAAO,WAE7DP,OAAOC,eAAenB,EAAS,aAAc,CAAEyB,OAAO,KAQvDnB,EAAoBoB,EAAI,SAASD,EAAOE,GAEvC,GADU,EAAPA,IAAUF,EAAQnB,EAAoBmB,IAC/B,EAAPE,EAAU,OAAOF,EACpB,GAAW,EAAPE,GAA8B,iBAAVF,GAAsBA,GAASA,EAAMG,WAAY,OAAOH,EAChF,IAAII,EAAKX,OAAOY,OAAO,MAGvB,GAFAxB,EAAoBgB,EAAEO,GACtBX,OAAOC,eAAeU,EAAI,UAAW,CAAET,YAAY,EAAMK,MAAOA,IACtD,EAAPE,GAA4B,iBAATF,EAAmB,IAAI,IAAIM,KAAON,EAAOnB,EAAoBQ,EAAEe,EAAIE,EAAK,SAASA,GAAO,OAAON,EAAMM,IAAQC,KAAK,KAAMD,IAC9I,OAAOF,GAIRvB,EAAoB2B,EAAI,SAAShC,GAChC,IAAIe,EAASf,GAAUA,EAAO2B,WAC7B,WAAwB,OAAO3B,EAAgB,SAC/C,WAA8B,OAAOA,GAEtC,OADAK,EAAoBQ,EAAEE,EAAQ,IAAKA,GAC5BA,GAIRV,EAAoBW,EAAI,SAASiB,EAAQC,GAAY,OAAOjB,OAAOkB,UAAUC,eAAe1B,KAAKuB,EAAQC,IAGzG7B,EAAoBgC,EAAI,GAIjBhC,EAAoBA,EAAoBiC,EAAI,G,gBClCrD,SAASC,EAAYC,GACnB,OAAO,WAKL,IAFA,IAAIjC,EAAIkC,UAAUC,OACZC,EAAO,GACNpC,KACLoC,EAAKpC,GAAKkC,UAAUlC,GAEF,IAAhBoC,EAAKD,OACPF,IACyB,IAAhBG,EAAKD,OACdF,EAAQG,EAAK,IAEbH,EAAQG,IASd,SAASC,EAAWC,EAAKC,EAAQH,EAAMI,GACrC,OAAO,SAAUC,GACf,IAAIC,EAAU,GACd,IACEA,EAAUC,KAAKC,UAAUR,GACzB,MAAOS,GACPH,EAAUN,EAAKU,KAAK,MAEtBR,EAAI/B,KAAOkC,EAAElC,KACb+B,EAAIS,QAAJ,UAAiBN,EAAEM,QAAnB,kBAAoCR,EAApC,YAA8CG,EAA9C,KACAF,EAAOF,IArEX9C,EAAQwD,YAAc,SAAUC,EAAKV,GACnC,IAAKU,EACH,MAAM,IAAIC,MAAJ,yCAA4CX,EAA5C,gBAA0DU,IAElE,IAAMb,EAAO,GAAGe,MAAMhD,KAAK+B,UAAW,GACtC,OAAO,IAAIkB,SAAQ,SAACnB,EAASO,GAC3B,IAAMa,EAAWrB,EAAYC,GAEvBqB,EAAUjB,EAAW,IAAIa,MAASX,EAAQH,EAAMI,GAChDe,EAAWnB,EAAKoB,OAAO,CAACH,EAAUC,IACxC,OAAOL,EAAIV,GAAQkB,MAAMR,EAAKM,OAIlC/D,EAAQkE,UAAY,SAAUC,GAC5B,IAAMC,EAAQpE,EAAQqE,UAAUF,GAC1BG,EAAWF,EAAMG,MAEvB,MAAO,CAACC,QADQJ,EAAMd,KAAK,KACVgB,aAGnBtE,EAAQqE,UAAY,WAAqB,IAAXF,EAAW,uDAAJ,GAEnC,IADAA,EAAOA,EAAKM,QAAQ,QAAS,KACpB9B,OAAS,GAAKwB,EAAKO,SAAS,KACnC,MAAM,IAAIhB,MAAJ,6BAER,OAAOS,EAAKQ,MAAM,KAAKC,OAAOC,W,cClChC7E,EAAQ8E,gBAAkB,SAAU7B,GAClC,OAAOA,GAAgB,kBAAXA,EAAElC,MAGhBf,EAAQ+E,oBAAsB,SAAU9B,GACtC,OAAOA,GAAgB,sBAAXA,EAAElC,O,cCLhB,IAAIjB,EAAO,KACPkF,EAAO,KAEXhF,EAAQqB,IAAM,WACZ,GAAKvB,EAGH,OAAOA,EAFP,MAAM,IAAI4D,MAAM,gCAMpB1D,EAAQiF,IAAM,SAAUC,EAASC,GAC/BrF,EAAOoF,EACPF,EAAOG,GAGTnF,EAAQoF,QAAU,WAChB,OAAOJ,I,gBCjBT,IAAMK,EAAQC,EAAQ,GAChBC,EAASD,EAAQ,GACjBxF,EAAOwF,EAAQ,GA+DrB,SAASE,EAAeC,EAAQC,GAC9B,OAAOL,EAAM7B,YAAYiC,EAAQ,eAAgBC,EAAS,CAAC5D,QAAQ,EAAM6D,WAAW,IAGtF,SAASC,EAAYH,EAAQC,GAC3B,OAAOL,EAAM7B,YAAYiC,EAAQ,eAAgBC,EAAS,CAAC5D,QAAQ,IAzDrE9B,EAAQqB,IAAM,SAAU8C,GAAoB,IAAd0B,EAAc,uDAAJ,GACtC,GAAI1B,GAAwB,iBAATA,EACjB,OAAOA,EAAK2B,YACRlC,QAAQnB,QAAQ0B,GAChBP,QAAQZ,OAAO,IAAI+C,SAAS,oBAAqB,oCAEvD,IAAM3B,EAAQiB,EAAMhB,UAAUF,GAC9B,OAAOC,EAAM4B,QAAO,SAACC,EAAKP,GACxB,OAAOO,EAAIC,MAAK,SAAAC,GACd,IAAIC,EAAOR,EAAYO,EAAKT,GAM5B,OALIG,EAAQ/D,SACVsE,EAAOA,EAAI,OAAO,SAAAnD,GAAC,OAAIsC,EAAOT,gBAAgB7B,GAC1CuC,EAAeW,EAAKT,GACpB9B,QAAQZ,OAAOC,OAEdmD,OAERxC,QAAQnB,QAAQ3C,EAAKuB,SAU1BrB,EAAQqG,KAAO,SAAUF,GACvB,OAgCF,SAASG,EAAqBC,EAAQC,GACpC,OAAOnB,EAAM7B,YAAY+C,EAAQ,eAC9BL,MAAK,SAAAO,GAAO,OAAIA,EAAQ9D,OAAS2D,EAAqBC,EAAQC,EAAIxC,OAAOyC,IAAYD,KAlCjFF,CAAqBH,EAAIO,eAAgB,KASlD1G,EAAQ2G,SAAW,SAAUR,GAC3B,OAAOnG,EAAQqG,KAAKF,GACjBD,MAAK,SAAAO,GACJ,IAAMG,EAAQH,EAAQI,KAAI,SAAAC,GACxB,OAAIA,EAAMhB,YACD9F,EAAQ2G,SAASG,GACrBZ,MAAK,SAAAa,GAAU,OAAI7F,OAAO8F,OAAOF,EAAO,CAACG,SAAUF,OAE/CnD,QAAQnB,QAAQqE,MAG3B,OAAOlD,QAAQsD,IAAIN,Q,sgBC5DzB,IAAMvB,EAAQC,EAAQ,GAChBC,EAASD,EAAQ,GACjBxF,EAAOwF,EAAQ,GACf6B,EAAO7B,EAAQ,GACf8B,EAAY9B,EAAQ,GACpB+B,EAAO/B,EAAQ,GACfgC,EAAQhC,EAAQ,GAqRtB,SAASiC,EAAWC,EAASC,EAAS1E,EAAQ8C,GAC5C,GAAI2B,IAAYC,EACd,OAAO7D,QAAQnB,UAFoC,MAOjD4C,EAAMnB,UAAUuD,GAFTC,EAL0C,EAKnDlD,QACUmD,EANyC,EAMnDrD,SAEF,OAAOV,QAAQsD,IAAI,CACjBlH,EAAQ4H,SAASJ,GACjBJ,EAAU/F,IAAIqG,EAAkB7B,KAC/BK,MAAK,YAAwB,aAAtB2B,EAAsB,KAAfC,EAAe,KAC9B,OAAOzC,EAAM7B,YAAYqE,EAAO9E,EAAQ+E,EAAWH,MAIvD,SAASI,EAAW/C,GAClB,GAAIA,IAAS5E,OAAO4H,YAAchD,IAAS5E,OAAO6H,UAChD,MAAM,IAAIvE,MAAJ,+BAAkCsB,IAhS5ChF,EAAQkI,YAAc,WACpB,OAAOrD,QAAQzE,OAAO+H,0BAaxBnI,EAAQoI,KAAO,WAAwB,IAAdvC,EAAc,uDAAJ,GAC3Bb,EAAO9D,OAAOkB,UAAUC,eAAe1B,KAAKkF,EAAS,QAAUA,EAAQb,KAAO5E,OAAO4H,WACrFK,EAAQxC,EAAQwC,OAAS,QAC/BN,EAAW/C,GACX,IAAMsD,EAAqBtD,IAAS5E,OAAO4H,cACtC9G,OAAOkB,UAAUC,eAAe1B,KAAKkF,EAAS,iBAAkBA,EAAQ0C,cAE7E,OAAO3E,QAAQnB,UACZyD,MAAK,kBAAMoC,EAAqBhB,EAAMkB,kBAAkBH,GAASA,KAEjEnC,MAAK,SAAAuC,GAAY,OAAIpD,EAAM7B,YAAYpD,OAAQ,0BAA2B4E,EAAMyD,MAChFvC,MAAK,SAAAwC,GAEJ,OADA5I,EAAKmF,IAAIyD,EAAG5I,KAAMkF,GACX0D,MASb1I,EAAQ2I,MAAQ,WACd,OAAOrB,EAAMqB,MAAM7I,EAAKsF,YAQ1BpF,EAAQ4I,QAAU,WAChB,OAAO9I,EAAKuB,OAedrB,EAAQ6I,SAAW,SAAU1E,GAAoB,IAAd0B,EAAc,uDAAJ,GAC3C,OAAOsB,EAAK9F,IAAI8C,GACb+B,MAAK,SAAA4C,GAAS,OAAI3B,EAAKd,KAAKyC,EAAWjD,OAY5C7F,EAAQ+I,UAAY,SAAU5E,EAAM6E,GAClC,OAAO7B,EAAK9F,IAAI8C,EAAM,CAACrC,QAAQ,EAAMmH,WAAW,IAC7C/C,MAAK,SAAA4C,GAAS,OAAI3B,EAAK+B,MAAMJ,EAAWE,EAAM,CAACG,QAAQ,QAW5DnJ,EAAQoJ,WAAa,SAAUjF,EAAM6E,GACnC,OAAO7B,EAAK9F,IAAI8C,EAAM,CAACrC,QAAQ,EAAMmH,WAAW,IAC7C/C,MAAK,SAAA4C,GAAS,OAAI3B,EAAK+B,MAAMJ,EAAWE,EAAM,CAACG,QAAQ,QAU5DnJ,EAAQqJ,OAAS,SAAUlF,GACzB,OAAOgD,EAAK9F,IAAI8C,GACb+B,MACC,SAAA4C,GAAS,OAAIzD,EAAM7B,YAAYsF,EAAW,aAC1C,SAAA7F,GAAC,OAAIsC,EAAOT,gBAAgB7B,GACxBW,QAAQnB,SAAQ,GAChBmB,QAAQZ,OAAOC,OAezBjD,EAAQsJ,OAAS,SAAU9B,EAASC,GAAuB,IAAd5B,EAAc,uDAAJ,GACrD,OAAO0B,EAAWC,EAASC,EAAS,SAAU5B,IAahD7F,EAAQuJ,KAAO,SAAU/B,EAASC,GAAuB,IAAd5B,EAAc,uDAAJ,GACnD,OAAO0B,EAAWC,EAASC,EAAS,SAAU5B,IAUhD7F,EAAQwJ,MAAQ,SAAUrF,GACxB,OAAOiD,EAAU/F,IAAI8C,GAClB+B,MACC,SAAAC,GAAG,OAAIA,IAAQrG,EAAKuB,MAChBuC,QAAQZ,OAAO,iDACfqC,EAAM7B,YAAY2C,EAAK,wBAC3B,SAAAlD,GAAC,OAAIsC,EAAOT,gBAAgB7B,GACxBW,QAAQnB,SAAQ,GAChBmB,QAAQZ,OAAOC,OAUzBjD,EAAQyJ,MAAQ,SAAUtF,GACxB,OAAOiD,EAAU/F,IAAI8C,EAAM,CAACrC,QAAQ,KAStC9B,EAAQ0J,OAAS,SAAUvF,GACzB,OAAOnE,EAAQ4H,SAASzD,GACrB+B,MAAK,kBAAM,KAAM,SAAAjD,GAAC,OAAIsC,EAAOT,gBAAgB7B,IAE1CW,QAAQZ,OAAOC,OAWvBjD,EAAQqH,KAAO,SAAUlD,GACvB,OAAOnE,EAAQ4H,SAASzD,GACrB+B,MAAK,SAAAY,GAAK,OAAIO,EAAKhG,IAAIyF,OAW5B9G,EAAQ2J,QAAU,SAAUxF,GAAoB,IAAd0B,EAAc,uDAAJ,GAC1C,OAAOuB,EAAU/F,IAAI8C,GAClB+B,MAAK,SAAAC,GAAG,OAAIN,EAAQ+D,KACjBxC,EAAUT,SAASR,GACnBiB,EAAUf,KAAKF,OAQvBnG,EAAQ6J,MAAQ,WACd,OAAO7J,EAAQ2J,QAAQ,KACpBzD,MAAK,SAAAO,GACJ,IAAMG,EAAQH,EAAQI,KAAI,SAAAC,GAAK,OAAIA,EAAMhB,YACrCT,EAAM7B,YAAYsD,EAAO,qBACzBzB,EAAM7B,YAAYsD,EAAO,aAE7B,OAAOlD,QAAQsD,IAAIN,OAUzB5G,EAAQ8J,OAAS,SAAU3F,GACzB,OAAOnE,EAAQ4H,SAASzD,GACrB+B,MAAK,SAAAY,GAAK,OAAIA,EAAMiD,YASzB/J,EAAQ4H,SAAW,SAAUzD,GAC3B,OAAOgD,EAAK9F,IAAI8C,GAAT,OACE,SAAAlB,GAAC,OAAIsC,EAAOR,oBAAoB9B,GACnCmE,EAAU/F,IAAI8C,GACdP,QAAQZ,OAAOC,OAUvBjD,EAAQgK,iBAAmB,SAAU7F,GACnC,OAAOgD,EAAK6C,iBAAiB7F,IAS/BnE,EAAQiK,kBAAoB,SAAU9F,GACpC,OAAOgD,EAAK8C,kBAAkB9F,K,gBCzRhC,IAAMkB,EAAQC,EAAQ,GAChBC,EAASD,EAAQ,GACjB8B,EAAY9B,EAAQ,GAgK1B,SAAS4E,EAAkBlB,GACzB,MAAoB,iBAATA,EACF,aAEA,2BAIX,SAASmB,EAAOnF,EAAMuB,EAAQY,GAC5B,OAAQnC,GACN,IAAK,cACH,OAAOuB,EAAO6D,kBAAkBjD,GAClC,IAAK,eACH,OAAOZ,EAAO8D,mBAAmBlD,GACnC,IAAK,UACH,OAAOZ,EAAO+D,cAAcnD,GAC9B,IAAK,OACL,QACE,OAAOZ,EAAOgE,WAAWpD,IAI/B,SAASqD,EAAkBrD,GAKzB,OAAO,IAAIsD,SAAStD,GAAMuD,OAG5B,SAASC,EAAgBlF,EAAQnB,GAC/B,OAAOe,EAAM7B,YAAYiC,EAAQ,UAAWnB,EAAU,CAACxC,QAAQ,EAAM6D,WAAW,IAGlF,SAASiF,EAAanF,EAAQnB,GAC5B,OAAOe,EAAM7B,YAAYiC,EAAQ,UAAWnB,EAAU,CAACxC,QAAQ,IAvLjE9B,EAAQqB,IAAM,SAAU8C,GAAoB,IAAd0B,EAAc,uDAAJ,GACtC,GAAI1B,GAAwB,iBAATA,EACjB,OAAOA,EAAK0G,OACRjH,QAAQnB,QAAQ0B,GAChBP,QAAQZ,OAAO,IAAI+C,SAAS,oBAAqB,oCAJb,MAMdV,EAAMnB,UAAUC,GAArCK,EANmC,EAMnCA,QAASF,EAN0B,EAM1BA,SAChB,OAAOV,QAAQnB,UACZyD,MAAK,kBAAMkB,EAAU/F,IAAImD,EAASqB,MAClCK,MAAK,SAAAC,GACJ,OAAIN,EAAQ/D,OACN+D,EAAQoD,UACH0B,EAAgBxE,EAAK7B,GAErBsG,EAAazE,EAAK7B,GAAlB,OACE,SAAArB,GAAC,OAAIsC,EAAOT,gBAAgB7B,GAC/B0H,EAAgBxE,EAAK7B,GACrBV,QAAQZ,OAAOC,MAGhB2H,EAAazE,EAAK7B,OAejCtE,EAAQkJ,MAAQ,SAAUJ,EAAWE,GAAoB,IAAdnD,EAAc,uDAAJ,GACnD,OAAOR,EAAM7B,YAAYsF,EAAW,gBACjC5C,MAAK,SAAA4E,GACJ,OAAO,IAAIlH,SAAQ,SAACnB,EAASO,GAC3B,GAAI6C,EAAQsD,OACV2B,EAAWC,KAAKD,EAAWnI,QAC3BmI,EAAWE,WAAavI,MACnB,CACL,IAAIwI,GAAY,EAChBH,EAAWE,WAAa,WACjBC,EAIHxI,KAHAwI,GAAY,EACZC,KAAKC,SAASD,KAAKE,YAMzBN,EAAWO,QAAUrI,EACrB,IAAM0H,EAAO,IAAIY,KAAK,CAACtC,GAAO,CAAChE,KAAMkF,EAAkBlB,KACvD8B,EAAW5B,MAAMwB,SAGpBxE,MAAK,kBAAM4C,MAehB9I,EAAQqG,KAAO,SAAUyC,GAAyB,IAAdjD,EAAc,uDAAJ,GAC5C,OAAOR,EAAM7B,YAAYsF,EAAW,QACjC5C,MAAK,SAAAiB,GACJ,MAAqB,SAAjBtB,EAAQb,KAEHwF,EAAkBrD,GACC,SAAjBtB,EAAQb,KACVmC,EAEA,IAAIvD,SAAQ,SAACnB,EAASO,GAC3B,IAAMuD,EAAS,IAAIgF,WACnBhF,EAAOiF,OAAS,kBAAM/I,EAAQ8D,EAAOkF,SACrClF,EAAO8E,QAAU,kBAAMrI,EAAOuD,EAAOmF,QAErCvB,EAAOtE,EAAQb,KAAMuB,EAAQY,UAYvCnH,EAAQgK,iBAAmB,SAAU7F,GAAM,MAEV,IAAIwH,gBAA3BC,EAFiC,EAEjCA,SAAUC,EAFuB,EAEvBA,SAKlB,OAJA7L,EAAQqB,IAAI8C,GACT+B,MAAK,SAAA4C,GAAS,OAAIzD,EAAM7B,YAAYsF,EAAW,WAC/C5C,MAAK,SAAAiB,GAAI,OAAI,IAAIsD,SAAStD,GAAM2E,KAAKC,OAAOF,MAF/C,OAGS,SAAA5I,GAAC,OAAI4I,EAASG,MAAM/I,MACtB2I,GAYT5L,EAAQiK,kBAAoB,SAAU9F,GAAoB,IAAd0B,EAAc,uDAAJ,GACpD,OAAO,IAAIoG,eAAe,CACxBC,MADwB,WAChB,WACN,OAAOlM,EAAQqB,IAAI8C,EAAM,CAAErC,QAAQ,EAAMmH,WAAW,IACjD/C,MAAK,SAAA4C,GAAS,OAAIzD,EAAM7B,YAAYsF,EAAW,mBAC/C5C,MAAK,SAAA4E,GACJ,EAAKA,WAAaA,EACdjF,EAAQsD,QACV2B,EAAWC,KAAKD,EAAWnI,YAInCuG,MAXwB,SAWlBF,GAAM,WACV,OAAO,IAAIpF,SAAQ,SAACnB,EAASO,GAC3B,IAAM0H,EAAO,IAAIY,KAAK,CAACtC,GAAO,CAAEhE,KAAMkF,EAAkBlB,KACxD,EAAK8B,WAAWE,WAAavI,EAC7B,EAAKqI,WAAWO,QAAUrI,EAC1B,EAAK8H,WAAW5B,MAAMwB,OAG1ByB,MAnBwB,WAmBhB,WACN,OAAO,IAAIvI,SAAQ,SAACnB,EAASO,GAC3B,EAAK8H,WAAWE,WAAavI,EAC7B,EAAKqI,WAAWO,QAAUrI,EAC1B,EAAK8H,WAAWK,SAAS,EAAKL,WAAWM,kB,gBC5JjD,IAAM/F,EAAQC,EAAQ,GAQtBtF,EAAQqB,IAAM,SAAUyF,GACtB,OAAOzB,EAAM7B,YAAYsD,EAAO,eAC7BZ,MAAK,SAAAkG,GACJ,MAAO,CACLvB,OAAQ/D,EAAM+D,OACd/E,YAAagB,EAAMhB,YACnB/E,KAAM+F,EAAM/F,KACZsL,SAAUvF,EAAMuF,SAChBC,iBAAkBF,EAASE,iBAC3BC,KAAMH,EAASG,W,sgBCjBvB,IAAMlH,EAAQC,EAAQ,GAyBtB,SAASkH,EAAiBxH,GACxB,OAAOA,IAAS5E,OAAO4H,WACnByE,UAAUC,wBACVD,UAAUE,uBAnBhB3M,EAAQwI,kBAAoB,SAAUH,GACpC,IAAMuE,EAAUJ,EAAiBpM,OAAO4H,YACxC,OAAO3C,EAAM7B,YAAYoJ,EAAS,eAAgBvE,GAC/CnC,MAAK,SAAAuC,GAAY,OAAIA,EAAe,EACjCA,EACA7E,QAAQZ,OAAR,wCAAgDqF,EAAhD,sBAAmEI,EAAnE,UAGRzI,EAAQ2I,MAAQ,SAAU3D,GACxB,IAAM4H,EAAUJ,EAAiBxH,GACjC,OAAOK,EAAM7B,YAAYoJ,EAAS,sBAC/B1G,MAAK,YAA+B,aACnC,MAAO,CAAC2G,UAD2B,KAChBpE,aADgB","file":"bro-fs.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"fs\"] = factory();\n\telse\n\t\troot[\"fs\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 4);\n","/**\n * Utils\n */\n\n/**\n * Calls async method of object with convertion callbacks into promise.\n *\n * @param {Object} obj\n * @param {String} method\n * @returns {Promise} promise resolved with returned value\n * (or array of values if callback called with more than one arguments)\n */\nexports.promiseCall = function (obj, method) {\n  if (!obj) {\n    throw new Error(`Can't call promisified method '${method}' of ${obj}`);\n  }\n  const args = [].slice.call(arguments, 2);\n  return new Promise((resolve, reject) => {\n    const callback = getCallback(resolve);\n    // create error before call to capture stack\n    const errback = getErrback(new Error(), method, args, reject);\n    const fullArgs = args.concat([callback, errback]);\n    return obj[method].apply(obj, fullArgs);\n  });\n};\n\nexports.parsePath = function (path) {\n  const parts = exports.splitPath(path);\n  const fileName = parts.pop();\n  const dirPath = parts.join('/');\n  return {dirPath, fileName};\n};\n\nexports.splitPath = function (path = '') {\n  path = path.replace(/^\\.\\//, ''); // remove './' at start\n  if (path.length > 1 && path.endsWith('/')) {\n    throw new Error(`Path can not end with '/'`);\n  }\n  return path.split('/').filter(Boolean);\n};\n\n/**\n * Create callback. Resolve should always be called with single argument:\n * - if underling callback called with zero or one argument - resolve call with the same\n * - if underling callback called with multiple arguments - resolve call with array of arguments\n *\n * See: https://github.com/vitalets/bro-fs/issues/7\n */\nfunction getCallback(resolve) {\n  return function () {\n    // not leaking arguments copy\n    // see: https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments\n    let i = arguments.length;\n    const args = [];\n    while (i--) {\n      args[i] = arguments[i];\n    }\n    if (args.length === 0) {\n      resolve();\n    } else if (args.length === 1) {\n      resolve(args[0]);\n    } else {\n      resolve(args);\n    }\n  };\n}\n\n/**\n * Convert DOMException to regular error to have normal stack trace\n * Also add some details to error message\n */\nfunction getErrback(err, method, args, reject) {\n  return function (e) {\n    let argsStr = '';\n    try {\n      argsStr = JSON.stringify(args);\n    } catch (ex) {\n      argsStr = args.join(', ');\n    }\n    err.name = e.name;\n    err.message = `${e.message} Call: ${method}(${argsStr})`;\n    reject(err);\n  };\n}\n","/**\n * Errors\n */\n\nexports.isNotFoundError = function (e) {\n  return e && e.name === 'NotFoundError';\n};\n\nexports.isTypeMismatchError = function (e) {\n  return e && e.name === 'TypeMismatchError';\n};\n","/**\n * Store link to fs root (singleton)\n */\n\nlet root = null;\nlet type = null;\n\nexports.get = function () {\n  if (!root) {\n    throw new Error('Filesystem not initialized.');\n  } else {\n    return root;\n  }\n};\n\nexports.set = function (newRoot, newType) {\n  root = newRoot;\n  type = newType;\n};\n\nexports.getType = function () {\n  return type;\n};\n","/**\n * Operations with directories\n */\n\nconst utils = require('./utils');\nconst errors = require('./errors');\nconst root = require('./root');\n\n/**\n * Returns DirectoryEntry by path\n * If options.create = true will create missing directories\n *\n * @param {String} path\n * @param {Object} options\n * @param {Boolean} options.create\n * @returns {Promise}\n */\nexports.get = function (path, options = {}) {\n  if (path && typeof path !== 'string') {\n    return path.isDirectory\n      ? Promise.resolve(path)\n      : Promise.reject(new DOMError('TypeMismatchError', 'Expected directory but got file'));\n  }\n  const parts = utils.splitPath(path);\n  return parts.reduce((res, dirName) => {\n    return res.then(dir => {\n      let task = getChildDir(dir, dirName);\n      if (options.create) {\n        task = task.catch(e => errors.isNotFoundError(e)\n          ? createChildDir(dir, dirName)\n          : Promise.reject(e));\n      }\n      return task;\n    });\n  }, Promise.resolve(root.get()));\n};\n\n/**\n * Reads dir entries\n * Note: readEntries returns maximum 100 files. To get all entries method should be called recursively\n * until empty array returned.\n * @see https://stackoverflow.com/questions/23823548/maximum-files-of-a-directory-that-can-be-read-by-filereaderreadentries-in-javas\n * @param {Object} dir\n */\nexports.read = function (dir) {\n  return readEntriesRecursive(dir.createReader(), []);\n};\n\n/**\n * Reads dir entries deeply\n *\n * @param {Object} dir\n * @returns {Promise<Array>}\n */\nexports.readDeep = function (dir) {\n  return exports.read(dir)\n    .then(entries => {\n      const tasks = entries.map(entry => {\n        if (entry.isDirectory) {\n          return exports.readDeep(entry)\n            .then(subEntries => Object.assign(entry, {children: subEntries}))\n        } else {\n          return Promise.resolve(entry);\n        }\n      });\n      return Promise.all(tasks);\n    });\n};\n\nfunction createChildDir(parent, dirName) {\n  return utils.promiseCall(parent, 'getDirectory', dirName, {create: true, exclusive: false});\n}\n\nfunction getChildDir(parent, dirName) {\n  return utils.promiseCall(parent, 'getDirectory', dirName, {create: false});\n}\n\nfunction readEntriesRecursive(reader, acc) {\n  return utils.promiseCall(reader, 'readEntries')\n    .then(entries => entries.length ? readEntriesRecursive(reader, acc.concat(entries)) : acc);\n}\n","/**\n * HTML5 Filesystem API\n * @module fs\n */\n\nconst utils = require('./utils');\nconst errors = require('./errors');\nconst root = require('./root');\nconst file = require('./file');\nconst directory = require('./directory');\nconst stat = require('./stat');\nconst quota = require('./quota');\n\n/**\n * Is filesystem API supported by current browser\n *\n * @returns {Boolean}\n */\nexports.isSupported = function () {\n  return Boolean(window.webkitRequestFileSystem);\n};\n\n/**\n * Init filesystem\n *\n * @param {Object} [options]\n * @param {Number} [options.type=window.PERSISTENT] window.PERSISTENT | window.TEMPORARY\n * @param {Number} [options.bytes=1Mb]\n * @param {Boolean} [options.requestQuota=true] show request quota popup for PERSISTENT type.\n * (for Chrome extensions with `unlimitedStorage` permission it is useful to pass options.requestQuota = false)\n * @returns {Promise}\n */\nexports.init = function (options = {}) {\n  const type = Object.prototype.hasOwnProperty.call(options, 'type') ? options.type : window.PERSISTENT;\n  const bytes = options.bytes || 1024 * 1024;\n  assertType(type);\n  const shouldRequestQuota = type === window.PERSISTENT\n    ? (Object.prototype.hasOwnProperty.call(options, 'requestQuota') ? options.requestQuota : true)\n    : false;\n  return Promise.resolve()\n    .then(() => shouldRequestQuota ? quota.requestPersistent(bytes) : bytes)\n    // webkitRequestFileSystem always returns fs even if quota not granted\n    .then(grantedBytes => utils.promiseCall(window, 'webkitRequestFileSystem', type, grantedBytes))\n    .then(fs => {\n      root.set(fs.root, type);\n      return fs;\n    });\n};\n\n/**\n * Gets used and granted bytes\n *\n * @returns {Promise<{usedBytes, grantedBytes}>}\n */\nexports.usage = function () {\n  return quota.usage(root.getType());\n};\n\n/**\n * Returns root directory\n *\n * @returns {FileSystemDirectoryEntry}\n */\nexports.getRoot = function () {\n  return root.get();\n};\n\n/**\n * Reads file content.\n * - `options.type='Blob'` returns a immutable snapshot of the file. Slower but safer.\n * - `options.type='File'` returns a mutable instance of {@link https://developer.mozilla.org/en-US/docs/Web/API/File File}. Faster but may have a data race.\n *\n * If file does not exist - error thrown.\n *\n * @param {String|FileSystemFileEntry} path\n * @param {Object} [options]\n * @param {String} [options.type='Text'] how content should be read: Text|ArrayBuffer|BinaryString|DataURL|Blob|File\n * @returns {Promise<String>}\n */\nexports.readFile = function (path, options = {}) {\n  return file.get(path)\n    .then(fileEntry => file.read(fileEntry, options));\n};\n\n/**\n * Writes data to file.\n * If file does not exist - it will be created.\n * If file already exists - it will be overwritten.\n *\n * @param {String} path\n * @param {String|Blob|File|ArrayBuffer} data\n * @returns {Promise}\n */\nexports.writeFile = function (path, data) {\n  return file.get(path, {create: true, overwrite: true})\n    .then(fileEntry => file.write(fileEntry, data, {append: false}));\n};\n\n/**\n * Appends data to file.\n * If file does not exist - it will be created.\n *\n * @param {String|FileSystemFileEntry} path\n * @param {String|Blob|File|ArrayBuffer} data\n * @returns {Promise}\n */\nexports.appendFile = function (path, data) {\n  return file.get(path, {create: true, overwrite: false})\n    .then(fileEntry => file.write(fileEntry, data, {append: true}));\n};\n\n/**\n * Removes file.\n * If file does not exist - no error thrown.\n *\n * @param {String|FileSystemFileEntry} path\n * @returns {Promise}\n */\nexports.unlink = function (path) {\n  return file.get(path)\n    .then(\n      fileEntry => utils.promiseCall(fileEntry, 'remove'),\n      e => errors.isNotFoundError(e)\n        ? Promise.resolve(false)\n        : Promise.reject(e)\n    );\n};\n\n/**\n * Renames file or directory.\n * If source file or directory does not exist - error thrown.\n * If target already exists - it will be overwritten.\n *\n * @param {String|FileSystemEntry} oldPath\n * @param {String} newPath\n * @param {Object} [options]\n * @param {Boolean} [options.create=false] create missing directories\n * @returns {Promise<FileSystemEntry>}\n */\nexports.rename = function (oldPath, newPath, options = {}) {\n  return moveOrCopy(oldPath, newPath, 'moveTo', options);\n};\n\n/**\n * Copies file or entire directory.\n * If file or directory does not exist - error thrown.\n *\n * @param {String|FileSystemEntry} oldPath\n * @param {String} newPath\n * @param {Object} [options]\n * @param {Boolean} [options.create=false] create missing directories\n * @returns {Promise<FileSystemEntry>}\n */\nexports.copy = function (oldPath, newPath, options = {}) {\n  return moveOrCopy(oldPath, newPath, 'copyTo', options);\n};\n\n/**\n * Removes directory recursively.\n * If directory does not exist - method does nothing without error.\n *\n * @param {String|FileSystemDirectoryEntry} path\n * @returns {Promise}\n */\nexports.rmdir = function (path) {\n  return directory.get(path)\n    .then(\n      dir => dir === root.get()\n        ? Promise.reject('Can not remove root. Use clear() to clear fs.')\n        : utils.promiseCall(dir, 'removeRecursively'),\n      e => errors.isNotFoundError(e)\n        ? Promise.resolve(false)\n        : Promise.reject(e)\n    )\n};\n\n/**\n * Recursively creates required directories in provided path.\n *\n * @param {String} path\n * @returns {Promise<FileSystemDirectoryEntry>}\n */\nexports.mkdir = function (path) {\n  return directory.get(path, {create: true});\n};\n\n/**\n * Checks that file or directory exists by provided path.\n *\n * @param {String} path\n * @returns {Promise<Boolean>}\n */\nexports.exists = function (path) {\n  return exports.getEntry(path)\n    .then(() => true, e => errors.isNotFoundError(e)\n      ? false\n      : Promise.reject(e)\n    );\n};\n\n/**\n * Gets info about file or directory.\n * If it does not exist - error thrown.\n *\n * @param {String|FileSystemEntry} path\n * @returns {Promise<StatObject>}\n */\nexports.stat = function (path) {\n  return exports.getEntry(path)\n    .then(entry => stat.get(entry));\n};\n\n/**\n * Reads directory content\n *\n * @param {String|FileSystemDirectoryEntry} path\n * @param {Object} [options]\n * @param {Boolean} [options.deep=false] read recursively and attach data as `children` property\n * @returns {Promise<Array<FileSystemEntry>>}\n */\nexports.readdir = function (path, options = {}) {\n  return directory.get(path)\n    .then(dir => options.deep\n      ? directory.readDeep(dir)\n      : directory.read(dir)\n    )\n};\n\n/**\n * Clears whole filesystem\n * @returns {Promise}\n */\nexports.clear = function () {\n  return exports.readdir('/')\n    .then(entries => {\n      const tasks = entries.map(entry => entry.isDirectory\n        ? utils.promiseCall(entry, 'removeRecursively')\n        : utils.promiseCall(entry, 'remove')\n      );\n      return Promise.all(tasks);\n    });\n};\n\n/**\n * Gets URL for path\n *\n * @param {String|FileSystemEntry} path\n * @returns {String}\n */\nexports.getUrl = function (path) {\n  return exports.getEntry(path)\n    .then(entry => entry.toURL())\n};\n\n/**\n * Gets file or directory\n *\n * @param {String|FileSystemEntry} path\n * @returns {Promise<FileSystemEntry>}\n */\nexports.getEntry = function (path) {\n  return file.get(path)\n    .catch(e => errors.isTypeMismatchError(e)\n      ? directory.get(path)\n      : Promise.reject(e)\n    );\n};\n\n/**\n * Create a {@link https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream ReadableStream} for reading\n *\n * @param {String|FileSystemFileEntry} path\n * @returns {ReadableStream}\n */\nexports.createReadStream = function (path) {\n  return file.createReadStream(path);\n};\n\n/**\n * Create a {@link https://developer.mozilla.org/en-US/docs/Web/API/WritableStream WritableStream} for writing\n *\n * @param {String|FileSystemFileEntry} path\n * @returns {WritableStream}\n */\nexports.createWriteStream = function (path) {\n  return file.createWriteStream(path);\n};\n\nfunction moveOrCopy(oldPath, newPath, method, options) {\n  if (oldPath === newPath) { // runtyper-disable-line\n    return Promise.resolve();\n  }\n  const {\n    dirPath: newParentDirPath,\n    fileName: newName,\n  } = utils.parsePath(newPath);\n  return Promise.all([\n    exports.getEntry(oldPath),\n    directory.get(newParentDirPath, options)\n  ]).then(([enrty, newParent]) => {\n    return utils.promiseCall(enrty, method, newParent, newName);\n  });\n}\n\nfunction assertType(type) {\n  if (type !== window.PERSISTENT && type !== window.TEMPORARY) {\n    throw new Error(`Unknown storage type ${type}`);\n  }\n}\n","/**\n * Operations with files\n */\n\nconst utils = require('./utils');\nconst errors = require('./errors');\nconst directory = require('./directory');\n\n/**\n * Returns FileEntry by path\n * If options.create = true will create missing directories and file\n *\n * @param {String|FileSystemFileEntry} path\n * @param {Object} [options]\n * @param {Boolean} [options.create]\n * @param {Boolean} [options.overwrite]\n * @returns {Promise}\n */\nexports.get = function (path, options = {}) {\n  if (path && typeof path !== 'string') {\n    return path.isFile\n      ? Promise.resolve(path)\n      : Promise.reject(new DOMError('TypeMismatchError', 'Expected file but got directory'));\n  }\n  const {dirPath, fileName} = utils.parsePath(path);\n  return Promise.resolve()\n    .then(() => directory.get(dirPath, options))\n    .then(dir => {\n      if (options.create) {\n        if (options.overwrite) {\n          return createChildFile(dir, fileName);\n        } else {\n          return getChildFile(dir, fileName)\n            .catch(e => errors.isNotFoundError(e)\n              ? createChildFile(dir, fileName)\n              : Promise.reject(e))\n        }\n      } else {\n        return getChildFile(dir, fileName);\n      }\n    });\n};\n\n/**\n * Writes to fileEntry using fileWriter\n *\n * @param {Object} fileEntry\n * @param {String} data\n * @param {Object} [options]\n * @param {Boolean} [options.append]\n * @param {String} [options.type] mimetype\n * @returns {Promise}\n */\nexports.write = function (fileEntry, data, options = {}) {\n  return utils.promiseCall(fileEntry, 'createWriter')\n    .then(fileWriter => {\n      return new Promise((resolve, reject) => {\n        if (options.append) {\n          fileWriter.seek(fileWriter.length);\n          fileWriter.onwriteend = resolve;\n        } else {\n          let truncated = false;\n          fileWriter.onwriteend = function () {\n            if (!truncated) {\n              truncated = true;\n              this.truncate(this.position);\n            } else {\n              resolve();\n            }\n          };\n        }\n        fileWriter.onerror = reject;\n        const blob = new Blob([data], {type: getMimeTypeByData(data)});\n        fileWriter.write(blob);\n      });\n    })\n    .then(() => fileEntry)\n};\n\n/**\n * Reads from fileEntry\n * \n * `options.type='Blob'` returns a snapshot of the file. Slower but safer.\n * \n * `options.type='File'` returns a real-time reference without any r/w lock. Faster but may have a data race.\n *\n * @param {Object} fileEntry\n * @param {Object} [options]\n * @param {String} [options.type] how content should be read\n * @returns {Promise<String>}\n */\nexports.read = function (fileEntry, options = {}) {\n  return utils.promiseCall(fileEntry, 'file')\n    .then(file => {\n      if (options.type === 'Blob') {\n        // see /test/file-vs-blob.js for why we need to \"freeze\" a Blob\n        return freezeMutableFile(file);\n      } else if (options.type === 'File') {\n        return file;\n      } else {\n        return new Promise((resolve, reject) => {\n          const reader = new FileReader();\n          reader.onload = () => resolve(reader.result);\n          reader.onerror = () => reject(reader.error);\n          // see: https://developer.mozilla.org/ru/docs/Web/API/FileReader\n          readAs(options.type, reader, file);\n        });\n      }\n    });\n};\n\n/**\n * Create a ReadableStream from path or fileEntry\n *\n * @param {String|FileSystemFileEntry} path\n * @returns {ReadableStream}\n */\nexports.createReadStream = function (path) {\n  /* global TransformStream:false */\n  const { readable, writable } = new TransformStream();\n  exports.get(path)\n    .then(fileEntry => utils.promiseCall(fileEntry, 'file'))\n    .then(file => new Response(file).body.pipeTo(writable))\n    .catch(e => writable.abort(e));\n  return readable;\n};\n\n/**\n * Create a WritableStream from fileEntry\n *\n * @param {String|FileSystemFileEntry} path\n * @param {Object} [options]\n * @param {Boolean} [options.append]\n * @param {String} [options.type] mimetype\n * @returns {WritableStream}\n */\nexports.createWriteStream = function (path, options = {}) {\n  return new WritableStream({\n    start() {\n      return exports.get(path, { create: true, overwrite: true })\n        .then(fileEntry => utils.promiseCall(fileEntry, 'createWriter'))\n        .then(fileWriter => {\n          this.fileWriter = fileWriter;\n          if (options.append) {\n            fileWriter.seek(fileWriter.length);\n          }\n        })\n    },\n    write(data) {\n      return new Promise((resolve, reject) => {\n        const blob = new Blob([data], { type: getMimeTypeByData(data) });\n        this.fileWriter.onwriteend = resolve;\n        this.fileWriter.onerror = reject;\n        this.fileWriter.write(blob);\n      });\n    },\n    close() {\n      return new Promise((resolve, reject) => {\n        this.fileWriter.onwriteend = resolve;\n        this.fileWriter.onerror = reject;\n        this.fileWriter.truncate(this.fileWriter.position);\n      });\n    }\n  });\n};\n\nfunction getMimeTypeByData(data) {\n  if (typeof data === 'string') {\n    return 'text/plain';\n  } else {\n    return 'application/octet-binary';\n  }\n}\n\nfunction readAs(type, reader, file) {\n  switch (type) {\n    case 'ArrayBuffer':\n      return reader.readAsArrayBuffer(file);\n    case 'BinaryString':\n      return reader.readAsBinaryString(file);\n    case 'DataURL':\n      return reader.readAsDataURL(file);\n    case 'Text':\n    default:\n      return reader.readAsText(file);\n  }\n}\n\nfunction freezeMutableFile(file) {\n  // I tried different APIs, but they either require reading the\n  // entire Blob into a buffer, or do not (deep) clone the Blob\n  // at all. Response is so far the best I can find.\n\n  return new Response(file).blob();\n}\n\nfunction createChildFile(parent, fileName) {\n  return utils.promiseCall(parent, 'getFile', fileName, {create: true, exclusive: false});\n}\n\nfunction getChildFile(parent, fileName) {\n  return utils.promiseCall(parent, 'getFile', fileName, {create: false});\n}\n","/**\n * Stat for file or directory\n */\n\nconst utils = require('./utils');\n\n/**\n * Gets stat info\n *\n * @param {FileSystemEntry} entry\n * @returns {Promise<StatObject>}\n */\nexports.get = function (entry) {\n  return utils.promiseCall(entry, 'getMetadata')\n    .then(metadata => {\n      return {\n        isFile: entry.isFile,\n        isDirectory: entry.isDirectory,\n        name: entry.name,\n        fullPath: entry.fullPath,\n        modificationTime: metadata.modificationTime,\n        size: metadata.size,\n      };\n    })\n};\n","/**\n * Requesting quota\n */\n\nconst utils = require('./utils');\n\n/**\n * Requesting quota is needed only for persistent storage.\n * See: https://developer.mozilla.org/en-US/docs/Web/API/LocalFileSystem\n *\n * @param {Number} bytes\n * @returns {Promise}\n */\nexports.requestPersistent = function (bytes) {\n  const storage = getStorageByType(window.PERSISTENT);\n  return utils.promiseCall(storage, 'requestQuota', bytes)\n    .then(grantedBytes => grantedBytes > 0\n      ? grantedBytes\n      : Promise.reject(`Quota not granted (requested: ${bytes}, granted: ${grantedBytes})`));\n};\n\nexports.usage = function (type) {\n  const storage = getStorageByType(type);\n  return utils.promiseCall(storage, 'queryUsageAndQuota')\n    .then(([usedBytes, grantedBytes]) => {\n      return {usedBytes, grantedBytes};\n    });\n};\n\nfunction getStorageByType(type) {\n  return type === window.PERSISTENT\n    ? navigator.webkitPersistentStorage\n    : navigator.webkitTemporaryStorage;\n}\n"],"sourceRoot":""}